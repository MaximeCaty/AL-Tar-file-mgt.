codeunit 51003 "TOO TAR Mgt."
{
    /* Cloud compatible TAR archive fast reading/writing
       ustar format with pax header
       This format can be by windows embeded archive explorer and 7zip

     Creat/Write :
        CreateTarArchive();
        WriteTarEntry(FileInStream: InStream; EntryName: Text);
        SaveTarArchive(OutStream: OutStream)

     Read :
        IsTAR(InputInStream: InStream): Boolean
        OpenTarArchive(TarInStreamParam: InStream)
        GetEntryList(var EntryList: List of [Text])
        ExtractEntry(EntryName: Text; var FileOutStream: OutStream)
        
    */

    var
        TempBlob: Codeunit "Temp Blob";
        TarOutStream: OutStream;
        ByteZero: Byte;

    procedure IsTAR(InputInStream: InStream): Boolean
    var
        Header: array[512] of Byte; // TAR header block
        Magic: Text[5];
        i: Integer;
    begin
        if InputInStream.Length < 512 then
            exit(false); // Not enough data for a header block

        for i := 1 to 512 do
            InputInStream.Read(Header[i]);

        // Extract bytes 258–262 (AL is 1-based; 257–261 in zero-based indexing)
        Magic := '';
        for i := 258 to 262 do
            Magic := Magic + Format(Header[i]);

        InputInStream.Position := 1; // Reset the stream for reuse
        exit(Magic = 'ustar');
    end;

    #region Write TAR


    procedure CreateTarArchive()
    var
        Header: array[512] of Byte;
        Sum: BigInteger;
        ChecksumOctal: Text;
        i: Integer;
        ExtendedData: Text;
        DataSize: BigInteger;
        Line: Text;
        Attr: Text;
        L: Integer;
        DL: Integer;
        PrevDL: Integer;
        Padding: BigInteger;
        CharZero: Char;
    begin
        TempBlob.CreateOutStream(TarOutStream);

        // Add a global PAX header to make the archive PAX-compatible (starts with 'pax_global_header')
        // This helps with compatibility, e.g., for UTF-8 or extended attributes, and ensures Windows can handle it properly
        CharZero := 0;
        Clear(Header);

        // Name
        SetStringToBytes(Header, 1, 'pax_global_header');

        // Mode: 0000000\0
        SetStringToBytes(Header, 101, '0000000' + CharZero);

        // UID: 0000000\0
        SetStringToBytes(Header, 109, '0000000' + CharZero);

        // GID: 0000000\0
        SetStringToBytes(Header, 117, '0000000' + CharZero);

        // Size: to be set later as octal
        // MTime: 00000000000\0
        SetStringToBytes(Header, 137, '00000000000' + CharZero);

        // Checksum: initially spaces
        for i := 149 to 156 do
            Header[i] := 32;

        // Typeflag: 'g' for global extended header
        Header[157] := 103; // Ord('g');

        // Linkname: empty

        // Magic: ustar\0 (but for PAX, it's ustar\0)
        SetStringToBytes(Header, 258, 'ustar' + CharZero);

        // Version: 00
        SetStringToBytes(Header, 264, '00');

        // Uname: root
        SetStringToBytes(Header, 266, 'root');

        // Gname: root
        SetStringToBytes(Header, 298, 'root');

        // Devmajor: 0000000\0
        SetStringToBytes(Header, 330, '0000000' + CharZero);

        // Devminor: 0000000\0
        SetStringToBytes(Header, 338, '0000000' + CharZero);

        // Prefix: empty

        // Prepare extended data (example: a comment; you can add more attributes like hdrcharset=UTF-8)
        Attr := 'comment=Generated by Microsoft Dynamics 365 Business Central';
        Line := Attr + '\n';
        L := StrLen(Line);
        DL := 2; // Initial guess for digits in length
        repeat
            PrevDL := DL;
            L := StrLen(Line) + DL + 1; // length digits + space + attr line
            DL := StrLen(Format(L));
        until DL = PrevDL;
        ExtendedData := Format(L) + ' ' + Attr + '\n';
        DataSize := StrLen(ExtendedData);

        // Set size in octal (11 digits + \0)
        SetStringToBytes(Header, 125, GetOctal(DataSize, 11) + CharZero);

        // Calculate checksum
        Sum := 0;
        for i := 1 to 512 do
            Sum += Header[i];
        ChecksumOctal := GetOctal(Sum, 6);
        SetStringToBytes(Header, 149, ChecksumOctal);
        Header[155] := 0; // NUL after 6 digits
        Header[156] := 32; // Space

        // Write the header
        for i := 1 to 512 do
            TarOutStream.Write(Header[i]);

        // Write the extended data
        SetStringToBytes(Header, 1, ExtendedData); // Reuse Header array for data since small
        for i := 1 to DataSize do
            TarOutStream.Write(Header[i]);

        // Padding for data
        Padding := (512 - (DataSize mod 512)) mod 512;
        if Padding > 0 then
            for i := 1 to Padding do
                TarOutStream.Write(ByteZero);

        // Now the archive is initialized with the global PAX header. You can add file entries after this.
    end;

    procedure WriteTarEntry(FileInStream: InStream; EntryName: Text)
    var
        Header: array[512] of Byte;
        FileSize: BigInteger;
        Mtime: BigInteger;
        Checksum: Integer;
        PaddingSize: BigInteger;
        DataByte: Byte;
        i: Integer;
    begin
        FileSize := FileInStream.Length;
        Clear(Header);
        // File name
        WriteStringToHeader(Header, 1, 100, EntryName);
        // Mode: 0644 octal (420 decimal)
        WriteOctalToHeader(Header, 101, 8, 420);
        // UID: 0
        WriteOctalToHeader(Header, 109, 8, 0);
        // GID: 0
        WriteOctalToHeader(Header, 117, 8, 0);
        // Size
        WriteOctalToHeader(Header, 125, 12, FileSize);
        // Mtime: Unix timestamp
        Mtime := (CurrentDateTime - CreateDateTime(19700101D, 000000T)) DIV 1000;
        WriteOctalToHeader(Header, 137, 12, Mtime);
        // Typeflag: '0' for normal file
        Header[157] := '0';
        // Magic: "ustar\0"
        Header[258] := 'u';
        Header[259] := 's';
        Header[260] := 't';
        Header[261] := 'a';
        Header[262] := 'r';
        Header[263] := 0;
        // Version: "00"
        Header[264] := '0';
        Header[265] := '0';
        // User name: "root"
        WriteStringToHeader(Header, 266, 32, 'root');
        // Group name: "root"
        WriteStringToHeader(Header, 298, 32, 'root');
        // Dev major: 0
        WriteOctalToHeader(Header, 329, 8, 0);
        // Dev minor: 0
        WriteOctalToHeader(Header, 337, 8, 0);
        // Set checksum field to 8 spaces for calculation
        for i := 149 to 156 do
            Header[i] := 32;
        // Calculate checksum
        Checksum := 0;
        for i := 1 to 512 do
            Checksum += Header[i];
        // Write checksum: 6 octal digits, \0, space
        WriteChecksumToHeader(Header, 149, Checksum);
        // Write header to stream
        for i := 1 to 512 do
            TarOutStream.Write(Header[i]);
        // Copy file data
        while not FileInStream.EOS do begin
            FileInStream.Read(DataByte);
            TarOutStream.Write(DataByte);
        end;
        // Padding to next 512-byte block
        PaddingSize := FileSize mod 512;
        if PaddingSize <> 0 then
            PaddingSize := 512 - PaddingSize;
        for i := 1 to PaddingSize do
            TarOutStream.Write(ByteZero);
    end;

    procedure SaveTarArchive(OutStream: OutStream)
    var
        TarInStream: InStream;
        B: Byte;
        i: Integer;
    begin
        // Write two zero-filled 512-byte blocks to end the archive
        for i := 1 to 1024 do
            TarOutStream.Write(ByteZero);
        // Copy the entire archive to the output stream
        TempBlob.CreateInStream(TarInStream);
        CopyStream(OutStream, TarInStream);
    end;
    #endregion

    #region Read TAR

    procedure OpenTarArchive(TarInStreamParam: InStream)
    var
        TempOutStream: OutStream;
        B: Byte;
    begin
        TempBlob.CreateOutStream(TempOutStream);
        CopyStream(TempOutStream, TarInStreamParam);
    end;

    procedure GetEntryList(var EntryList: List of [Text])
    var
        LocalInStream: InStream;
        Header: array[512] of Byte;
        Name: Text;
        Size: BigInteger;
        Padding: BigInteger;
    begin
        TempBlob.CreateInStream(LocalInStream);
        while ReadHeader(LocalInStream, Header) do begin
            Name := GetFullNameFromHeader(Header);
            if Name <> '' then
                EntryList.Add(Name);
            Size := GetSizeFromHeader(Header);
            SkipBytes(LocalInStream, Size);
            Padding := (512 - (Size mod 512)) mod 512;
            SkipBytes(LocalInStream, Padding);
        end;
    end;

    procedure ExtractEntry(EntryName: Text; FileOutStream: OutStream)
    var
        LocalInStream: InStream;
        Header: array[512] of Byte;
        Name: Text;
        Size: BigInteger;
        Padding: BigInteger;
        B: Byte;
        i: BigInteger;
        Found: Boolean;
    begin
        TempBlob.CreateInStream(LocalInStream);
        Found := false;
        while (not Found) and ReadHeader(LocalInStream, Header) do begin
            Name := GetFullNameFromHeader(Header);
            Size := GetSizeFromHeader(Header);
            if Name = EntryName then begin
                Found := true;
                for i := 1 to Size do begin
                    LocalInStream.Read(B);
                    FileOutStream.Write(B);
                end;
            end else begin
                SkipBytes(LocalInStream, Size);
                Padding := (512 - (Size mod 512)) mod 512;
                SkipBytes(LocalInStream, Padding);
            end;
        end;
        if not Found then
            Error('Entry "%1" not found in the archive.', EntryName);
    end;
    #endregion

    #region Tech. Read

    local procedure ReadHeader(var InStr: InStream; var Header: array[512] of Byte): Boolean
    var
        i: Integer;
        BytesRead: Integer;
        AllZero: Boolean;
    begin
        Clear(Header);
        for i := 1 to 512 do begin
            BytesRead := InStr.Read(Header[i]);
            if BytesRead = 0 then
                exit(false);
        end;
        AllZero := true;
        for i := 1 to 512 do
            if Header[i] <> 0 then begin
                AllZero := false;
                break;
            end;
        exit(not AllZero);
    end;

    local procedure SkipBytes(var InStr: InStream; Count: BigInteger)
    begin
        InStr.Position := InStr.Position + Count;
    end;

    local procedure LetterToByte(Letter: Text[1]) LetterByte: Byte;
    begin
        LetterByte := Letter[1];
    end;

    local procedure GetFullNameFromHeader(var Header: array[512] of Byte): Text
    var
        Name: Text;
        Prefix: Text;
        i: Integer;
        Chr: Char;
    begin
        Name := '';
        for i := 1 to 100 do begin
            if Header[i] = 0 then
                break;
            Chr := Header[i];
            Name += Chr;
        end;
        // Check for USTAR format and prefix
        if (Header[258] = LetterToByte('u')) and (Header[259] = LetterToByte('s')) and (Header[260] = LetterToByte('t')) and (Header[261] = LetterToByte('a')) and (Header[262] = LetterToByte('r')) and (Header[263] = 0) then begin
            Prefix := '';
            for i := 346 to 500 do begin
                if Header[i] = 0 then
                    break;
                Chr := Header[i];
                Prefix += Chr;
            end;
            if Prefix <> '' then
                Name := Prefix + '/' + Name;
        end;
        exit(Name);
    end;

    local procedure GetSizeFromHeader(var Header: array[512] of Byte): BigInteger
    var
        OctalStr: Text;
        i: Integer;
        Chr: Char;
    begin
        OctalStr := '';
        for i := 125 to 135 do begin
            if Header[i] = 0 then
                break;
            Chr := Header[i];
            OctalStr += Chr;
        end;
        OctalStr := DelChr(OctalStr, '<', ' '); // Trim leading spaces if any
        if OctalStr = '' then
            exit(0);
        exit(FromOctal(OctalStr));
    end;

    local procedure FromOctal(Octal: Text): BigInteger
    var
        Value: BigInteger;
        Digit: Integer;
        i: Integer;
    begin
        Value := 0;
        for i := 1 to StrLen(Octal) do begin
            Digit := Octal[i] - 48; // Decimal of '0' ascii character
            if (Digit < 0) or (Digit > 7) then
                Error('Invalid octal digit in size field.');
            Value := Value * 8 + Digit;
        end;
        exit(Value);
    end;
    #endregion

    #region Tech. Write
    local procedure SetStringToBytes(var Arr: array[512] of Byte; StartPos: Integer; Str: Text)
    var
        j: Integer;
    begin
        for j := 1 to StrLen(Str) do
            Arr[StartPos + j - 1] := Str[j];
    end;

    local procedure ToOctal(Value: BigInteger; Len: Integer): Text
    var
        Octal: Text;
        Remainder: Integer;
    begin
        Octal := '';
        if Value = 0 then
            Octal := '0';
        while Value > 0 do begin
            Remainder := Value mod 8;
            Octal := Format(Remainder) + Octal;
            Value := Value div 8;
        end;
        while StrLen(Octal) < Len do
            Octal := '0' + Octal;
        exit(Octal);
    end;

    local procedure GetOctal(Value: BigInteger; Digits: Integer): Text
    var
        Octal: Text;
        V: BigInteger;
    begin
        Octal := '';
        V := Value;
        if V = 0 then
            Octal := '0'
        else
            while V > 0 do begin
                Octal := Format(V mod 8) + Octal;
                V := V div 8;
            end;
        while StrLen(Octal) < Digits do
            Octal := '0' + Octal;
        exit(Octal);
    end;

    local procedure WriteStringToHeader(var Header: array[512] of Byte; Pos: Integer; MaxLen: Integer; Value: Text)
    var
        i: Integer;
    begin
        for i := 1 to StrLen(Value) do
            if i <= MaxLen then
                Header[Pos + i - 1] := Value[i];
    end;

    local procedure WriteOctalToHeader(var Header: array[512] of Byte; Pos: Integer; FieldLen: Integer; Value: BigInteger)
    var
        Octal: Text;
        i: Integer;
    begin
        Octal := ToOctal(Value, FieldLen - 1);
        for i := 1 to StrLen(Octal) do
            Header[Pos + i - 1] := Octal[i];
        Header[Pos + FieldLen - 1] := 0;
    end;

    local procedure WriteChecksumToHeader(var Header: array[512] of Byte; Pos: Integer; Value: Integer)
    var
        Octal: Text;
        i: Integer;
    begin
        Octal := ToOctal(Value, 6);
        for i := 1 to 6 do
            Header[Pos + i - 1] := Octal[i];
        Header[Pos + 6] := 0;
        Header[Pos + 7] := 32;
    end;

    #endregion        
}