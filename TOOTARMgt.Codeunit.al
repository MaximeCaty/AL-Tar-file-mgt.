codeunit 51003 "TOO TAR Mgt."
{
    /* Cloud compatible TAR archive fast reading/writing
       ustar format with pax header
       This format can be by windows embeded archive explorer and 7zip

     Creat/Write :
        CreateTarArchive();
        WriteTarEntry(FileInStream: InStream; EntryName: Text);
        SaveTarArchive(OutStream: OutStream)

     Read :
        IsTAR(InputInStream: InStream): Boolean
        OpenTarArchive(TarInStreamParam: InStream)
        GetEntryList(var EntryList: List of [Text])
        ExtractEntry(EntryName: Text; var FileOutStream: OutStream)
        
        Note : for faster files extraction, first call GetEntryList to build files position dictionnay and avoid full scan at each file.
    */

    var
        TempBlob: Codeunit "Temp Blob";
        TarOutStream: OutStream;
        ByteZero: Byte;
        EntryIndex: Dictionary of [Text, BigInteger]; // Name -> Position in stream
        EntryNames: List of [Text];                   // cached list of file names (order preserved)

    procedure IsTAR(var InputInStream: InStream): Boolean
    var
        Header: array[512] of Byte; // TAR header block
        Magic: Text[5];
        i: Integer;
    begin
        if InputInStream.Length < 512 then
            exit(false); // Not enough data for a header block

        for i := 1 to 512 do
            InputInStream.Read(Header[i]);

        // Extract bytes 258–262 (AL is 1-based; 257–261 in zero-based indexing)
        Magic := '';
        for i := 258 to 262 do
            Magic := Magic + Format(Header[i]);

        InputInStream.Position := 1; // Reset the stream for reuse
        exit(Magic = 'ustar');
    end;

    #region Write TAR


    procedure CreateTarArchive()
    var
        Header: array[512] of Byte;
        Sum: BigInteger;
        ChecksumOctal: Text;
        i: Integer;
        ExtendedData: Text;
        DataSize: BigInteger;
        Line: Text;
        Attr: Text;
        L: Integer;
        DL: Integer;
        PrevDL: Integer;
        Padding: BigInteger;
        CharZero: Char;
    begin
        TempBlob.CreateOutStream(TarOutStream);

        // Add a global PAX header to make the archive PAX-compatible (starts with 'pax_global_header')
        // This helps with compatibility, e.g., for UTF-8 or extended attributes, and ensures Windows can handle it properly
        CharZero := 0;
        Clear(Header);

        // Name
        SetStringToBytes(Header, 1, 'pax_global_header');

        // Mode: 0000000\0
        SetStringToBytes(Header, 101, '0000000' + CharZero);

        // UID: 0000000\0
        SetStringToBytes(Header, 109, '0000000' + CharZero);

        // GID: 0000000\0
        SetStringToBytes(Header, 117, '0000000' + CharZero);

        // Size: to be set later as octal
        // MTime: 00000000000\0
        SetStringToBytes(Header, 137, '00000000000' + CharZero);

        // Checksum: initially spaces
        for i := 149 to 156 do
            Header[i] := 32;

        // Typeflag: 'g' for global extended header
        Header[157] := 103; // Ord('g');

        // Linkname: empty

        // Magic: ustar\0 (but for PAX, it's ustar\0)
        SetStringToBytes(Header, 258, 'ustar' + CharZero);

        // Version: 00
        SetStringToBytes(Header, 264, '00');

        // Uname: root
        SetStringToBytes(Header, 266, 'root');

        // Gname: root
        SetStringToBytes(Header, 298, 'root');

        // Devmajor: 0000000\0
        SetStringToBytes(Header, 330, '0000000' + CharZero);

        // Devminor: 0000000\0
        SetStringToBytes(Header, 338, '0000000' + CharZero);

        // Prefix: empty

        // Prepare extended data (example: a comment; you can add more attributes like hdrcharset=UTF-8)
        Attr := 'comment=Generated by Microsoft Dynamics 365 Business Central';
        Line := Attr + '\n';
        L := StrLen(Line);
        DL := 2; // Initial guess for digits in length
        repeat
            PrevDL := DL;
            L := StrLen(Line) + DL + 1; // length digits + space + attr line
            DL := StrLen(Format(L));
        until DL = PrevDL;
        ExtendedData := Format(L) + ' ' + Attr + '\n';
        DataSize := StrLen(ExtendedData);

        // Set size in octal (11 digits + \0)
        SetStringToBytes(Header, 125, GetOctal(DataSize, 11) + CharZero);

        // Calculate checksum
        Sum := 0;
        for i := 1 to 512 do
            Sum += Header[i];
        ChecksumOctal := GetOctal(Sum, 6);
        SetStringToBytes(Header, 149, ChecksumOctal);
        Header[155] := 0; // NUL after 6 digits
        Header[156] := 32; // Space

        // Write the header
        for i := 1 to 512 do
            TarOutStream.Write(Header[i]);

        // Write the extended data
        SetStringToBytes(Header, 1, ExtendedData); // Reuse Header array for data since small
        for i := 1 to DataSize do
            TarOutStream.Write(Header[i]);

        // Padding for data
        Padding := (512 - (DataSize mod 512)) mod 512;
        if Padding > 0 then
            for i := 1 to Padding do
                TarOutStream.Write(ByteZero);

        // Now the archive is initialized with the global PAX header. You can add file entries after this.
    end;

    procedure WriteTarEntry(var FileInStream: InStream; EntryName: Text)
    var
        Header: array[512] of Byte;
        FileSize: BigInteger;
        Mtime: BigInteger;
        Checksum: Integer;
        PaddingSize: BigInteger;
        i: Integer;
    begin
        FileSize := FileInStream.Length;
        Clear(Header);
        // File name
        WriteStringToHeader(Header, 1, 100, EntryName);
        // Mode: 0644 octal (420 decimal)
        WriteOctalToHeader(Header, 101, 8, 420);
        // UID: 0
        WriteOctalToHeader(Header, 109, 8, 0);
        // GID: 0
        WriteOctalToHeader(Header, 117, 8, 0);
        // Size
        WriteOctalToHeader(Header, 125, 12, FileSize);
        // Mtime: Unix timestamp
        Mtime := (CurrentDateTime - CreateDateTime(19700101D, 000000T)) DIV 1000;
        WriteOctalToHeader(Header, 137, 12, Mtime);
        // Typeflag: '0' for normal file
        Header[157] := '0';
        // Magic: "ustar\0"
        Header[258] := 'u';
        Header[259] := 's';
        Header[260] := 't';
        Header[261] := 'a';
        Header[262] := 'r';
        Header[263] := 0;
        // Version: "00"
        Header[264] := '0';
        Header[265] := '0';
        // User name: "root"
        WriteStringToHeader(Header, 266, 32, 'root');
        // Group name: "root"
        WriteStringToHeader(Header, 298, 32, 'root');
        // Dev major: 0
        WriteOctalToHeader(Header, 329, 8, 0);
        // Dev minor: 0
        WriteOctalToHeader(Header, 337, 8, 0);
        // Set checksum field to 8 spaces for calculation
        for i := 149 to 156 do
            Header[i] := 32;
        // Calculate checksum
        Checksum := 0;
        for i := 1 to 512 do
            Checksum += Header[i];
        // Write checksum: 6 octal digits, \0, space
        WriteChecksumToHeader(Header, 149, Checksum);
        // Write header to stream
        for i := 1 to 512 do
            TarOutStream.Write(Header[i]);
        // Copy file data
        CopyStream(TarOutStream, FileInStream);
        // Padding to next 512-byte block
        PaddingSize := FileSize mod 512;
        if PaddingSize <> 0 then
            PaddingSize := 512 - PaddingSize;
        for i := 1 to PaddingSize do
            TarOutStream.Write(ByteZero);
    end;

    procedure SaveTarArchive(var OutStream: OutStream)
    var
        TarInStream: InStream;
        i: Integer;
    begin
        // Write two zero-filled 512-byte blocks to end the archive
        for i := 1 to 1024 do
            TarOutStream.Write(ByteZero);
        // Copy the entire archive to the output stream
        TempBlob.CreateInStream(TarInStream);
        CopyStream(OutStream, TarInStream);
    end;

    procedure SaveTarArchive(var vTempBlob: Codeunit "Temp Blob")
    var
        i: Integer;
    begin
        // Write two zero-filled 512-byte blocks to end the archive
        for i := 1 to 1024 do
            TarOutStream.Write(ByteZero);
        vTempBlob := TempBlob;
    end;
    #endregion

    #region Read TAR
    procedure OpenTarArchive(var TarInStreamParam: InStream)
    var
        TempOutStream: OutStream;
    begin
        TempBlob.CreateOutStream(TempOutStream);
        CopyStream(TempOutStream, TarInStreamParam);
        // Optimization: Clear any existing index
        Clear(EntryIndex);
    end;

    procedure GetEntryList(var Names: List of [Text])
    begin
        if EntryIndex.Count = 0 then
            BuildIndexAndGetNames(Names)
        else
            Names := EntryNames;  // Already cached
    end;

    procedure ExtractEntry(EntryName: Text; FileOutStream: OutStream)
    var
        LocalInStream: InStream;
        Header: array[512] of Byte;
        Name: Text;
        Size: BigInteger;
        Padding: BigInteger;
        Found: Boolean;
        StartPos: BigInteger;
    begin
        // Optimization: If index exists, seek directly to the entry's data position
        if EntryIndex.ContainsKey(EntryName) then begin
            TempBlob.CreateInStream(LocalInStream);
            StartPos := EntryIndex.Get(EntryName);
            LocalInStream.Position := StartPos - 512; // Back up to header start
            if not ReadHeader(LocalInStream, Header) then
                Error('Invalid index for entry "%1".', EntryName);
            Size := GetSizeFromHeader(Header); // Still need size
            CopyStream(FileOutStream, LocalInStream, Size);
            exit;
        end;
        // Fallback: Sequential scan
        TempBlob.CreateInStream(LocalInStream);
        Found := false;
        while (not Found) and ReadHeader(LocalInStream, Header) do begin
            Name := GetFullNameFromHeader(Header);
            if Name = EntryName then begin // Check name before computing size (cheaper)
                Found := true;
                Size := GetSizeFromHeader(Header);
                CopyStream(FileOutStream, LocalInStream, Size);
            end else begin
                Size := GetSizeFromHeader(Header);
                SkipBytes(LocalInStream, Size);
                Padding := (512 - (Size mod 512)) mod 512;
                SkipBytes(LocalInStream, Padding);
            end;
        end;
        if not Found then
            Error('Entry "%1" not found in the archive.', EntryName);
    end;
    #endregion

    #region Tech. Read
    local procedure BuildIndexAndGetNames(var Names: List of [Text]): Boolean
    var
        InStr: InStream;
        Header: array[512] of Byte;
        Name: Text;
        Size, Padding : BigInteger;
        DataStartPos: BigInteger;
    begin
        Clear(EntryIndex);
        Clear(EntryNames);
        Clear(Names);

        TempBlob.CreateInStream(InStr);

        while ReadHeader(InStr, Header) do begin
            DataStartPos := InStr.Position;         // Position = right after the 512-byte header
            Name := GetFullNameFromHeader(Header);

            if Name <> '' then begin
                EntryIndex.Add(Name, DataStartPos);
                EntryNames.Add(Name);
                Names.Add(Name);                        // Return ordered list
            end;

            Size := GetSizeFromHeader(Header);
            SkipBytes(InStr, Size);
            Padding := (512 - (Size mod 512)) mod 512;
            SkipBytes(InStr, Padding);
        end;

        exit(EntryIndex.Count > 0);
    end;

    local procedure ReadHeader(var InStr: InStream; var Header: array[512] of Byte): Boolean
    var
        i: Integer;
        BytesRead: Integer;
        AllZero: Boolean;
    begin
        Clear(Header);
        AllZero := true; // Optimization: Combine read and all-zero check in one loop
        for i := 1 to 512 do begin
            BytesRead := InStr.Read(Header[i]);
            if BytesRead = 0 then
                exit(false);
            if Header[i] <> 0 then
                AllZero := false;
        end;
        exit(not AllZero);
    end;

    local procedure SkipBytes(var InStr: InStream; Count: BigInteger)
    begin
        InStr.Position := InStr.Position + Count;
    end;

    local procedure GetFullNameFromHeader(var Header: array[512] of Byte): Text
    var
        Result: Text[512];
        Pos, i : Integer;
    begin
        Pos := 0;

        // Check USTAR
        if (Header[258] = 117) and (Header[259] = 115) and (Header[260] = 116) and
           (Header[261] = 97) and (Header[262] = 114) and (Header[263] = 0) then begin
            for i := 346 to 500 do begin
                if Header[i] = 0 then break;
                Pos += 1;
                Result[Pos] := Header[i];
            end;
            if Pos > 0 then begin
                Pos += 1;
                Result[Pos] := 47; // '/'
            end;
        end;

        for i := 1 to 100 do begin
            if Header[i] = 0 then break;
            Pos += 1;
            Result[Pos] := Header[i];
        end;

        exit(CopyStr(Result, 1, Pos));
    end;

    local procedure GetSizeFromHeader(var Header: array[512] of Byte): BigInteger
    var
        Octal: Text[12];
        Pos, i : Integer;
    begin
        Pos := 0;
        for i := 125 to 136 do begin
            if Header[i] = 0 then break;
            Pos += 1;
            Octal[Pos] := Header[i];
        end;
        Octal := DelChr(Octal, '<>', ' '); // Remove all spaces
        if Octal = '' then exit(0);
        exit(FromOctal(Octal));
    end;

    local procedure FromOctal(Octal: Text): BigInteger
    var
        Value: BigInteger;
        Digit: Integer;
        i: Integer;
    begin
        Value := 0;
        for i := 1 to StrLen(Octal) do begin
            Digit := Octal[i] - 48; // '0'
            if (Digit < 0) or (Digit > 7) then
                Error('Invalid octal digit in size field.');
            Value := Value * 8 + Digit;
        end;
        exit(Value);
    end;
    #endregion

    #region Tech. Write
    local procedure SetStringToBytes(var Arr: array[512] of Byte; StartPos: Integer; Str: Text)
    var
        j: Integer;
    begin
        for j := 1 to StrLen(Str) do
            Arr[StartPos + j - 1] := Str[j];
    end;

    local procedure ToOctal(Value: BigInteger; Len: Integer): Text
    var
        Octal: Text;
        Remainder: Integer;
    begin
        Octal := '';
        if Value = 0 then
            Octal := '0';
        while Value > 0 do begin
            Remainder := Value mod 8;
            Octal := Format(Remainder) + Octal;
            Value := Value div 8;
        end;
        while StrLen(Octal) < Len do
            Octal := '0' + Octal;
        exit(Octal);
    end;

    local procedure GetOctal(Value: BigInteger; Digits: Integer): Text
    var
        Octal: Text;
        V: BigInteger;
    begin
        Octal := '';
        V := Value;
        if V = 0 then
            Octal := '0'
        else
            while V > 0 do begin
                Octal := Format(V mod 8) + Octal;
                V := V div 8;
            end;
        while StrLen(Octal) < Digits do
            Octal := '0' + Octal;
        exit(Octal);
    end;

    local procedure WriteStringToHeader(var Header: array[512] of Byte; Pos: Integer; MaxLen: Integer; Value: Text)
    var
        i: Integer;
    begin
        for i := 1 to StrLen(Value) do
            if i <= MaxLen then
                Header[Pos + i - 1] := Value[i];
    end;

    local procedure WriteOctalToHeader(var Header: array[512] of Byte; Pos: Integer; FieldLen: Integer; Value: BigInteger)
    var
        Octal: Text;
        i: Integer;
    begin
        Octal := ToOctal(Value, FieldLen - 1);
        for i := 1 to StrLen(Octal) do
            Header[Pos + i - 1] := Octal[i];
        Header[Pos + FieldLen - 1] := 0;
    end;

    local procedure WriteChecksumToHeader(var Header: array[512] of Byte; Pos: Integer; Value: Integer)
    var
        Octal: Text;
        i: Integer;
    begin
        Octal := ToOctal(Value, 6);
        for i := 1 to 6 do
            Header[Pos + i - 1] := Octal[i];
        Header[Pos + 6] := 0;
        Header[Pos + 7] := 32;
    end;

    #endregion        
}
